% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/optimCLHS.R
\name{optimCLHS}
\alias{objCLHS}
\alias{optimCLHS}
\title{Optimization of sample configurations for spatial trend identification
and estimation (IV)}
\usage{
optimCLHS(points, candi, covars, use.coords = FALSE,
  schedule = scheduleSPSANN(), plotit = FALSE, track = FALSE, boundary,
  progress = TRUE, verbose = FALSE, weights = list(O1 = 1/3, O2 = 1/3, O3
  = 1/3))

objCLHS(points, candi, covars, use.coords = FALSE, weights = list(O1 = 1/3,
  O2 = 1/3, O3 = 1/3))
}
\arguments{
\item{points}{Integer value, integer vector, data frame or matrix. If
\code{points} is an integer value, it defines the number of points that
should be randomly sampled from \code{candi} to form the starting system
configuration. If \code{points} is a vector of integer values, it contains
the row indexes of \code{candi} that correspond to the points that form the
starting system configuration. If \code{points} is a data frame or matrix,
it must have three columns in the following order: \code{[, "id"]} the
row indexes of \code{candi} that correspond to each point, \code{[, "x"]}
the projected x-coordinates, and \code{[, "y"]} the projected y-coordinates.
Note that in the later case, \code{points} must be a subset of \code{candi}.}

\item{candi}{Data frame or matrix with the candidate locations for the
jittered points. \code{candi} must have two columns in the following
order: \code{[, "x"]} the projected x-coordinates, and \code{[, "y"]} the
projected y-coordinates.}

\item{covars}{Data frame or matrix with the covariates in the columns.}

\item{use.coords}{Logical value. Should the geographic coordinates be used
as covariates? Defaults to \code{use.coords = FALSE}.}

\item{schedule}{List with 11 named sub-arguments defining the control
parameters of the cooling schedule. See \code{\link[spsann]{scheduleSPSANN}}.}

\item{plotit}{Logical for plotting the optimization results, including
a) the progress of the objective function, and b) the starting (gray) and
current system configuration (black), and the maximum jitter in the
x- and y-coordinates. The plots are updated at each 10 jitters. Defaults to
\code{plotit = FALSE}.}

\item{track}{Logical value. Should the evolution of the energy state be
recorded and returned with the result? If \code{track = FALSE} (the default),
only the starting and ending energy states are returned with the results.}

\item{boundary}{SpatialPolygon defining the boundary of the spatial domain.
If missing and \code{plotit = TRUE}, \code{boundary} is estimated from
\code{candi}.}

\item{progress}{Logical for printing a progress bar. Defaults to
\code{progress = TRUE}.}

\item{verbose}{Logical for printing messages about the progress of the
optimization. Defaults to \code{verbose = FALSE}.}

\item{weights}{List with named sub-arguments. The weights assigned to each
one of the objective functions that form the multi-objective optimization
problem (MOOP). They must be named after the respective objective function
to which they apply. The weights must be equal to or larger than 0 and sum
to 1. The default option gives equal weights to all objective functions.}
}
\value{
\code{optimCLHS} returns a matrix: the optimized sample configuration.

\code{objCLHS} returns a numeric value: the energy state of the sample
configuration - the objective function value.
}
\description{
Optimize a sample configuration for spatial trend identification and
estimation using the method proposed by Minasny and McBratney (2006), known
as the conditioned Latin hypercube sampling. An utility function \emph{U} is
defined so that the sample reproduces the marginal distribution and
correlation matrix of the numeric covariates, and the class proportions of
the factor covariates (\bold{CLHS}). The utility function is obtained
aggregating three objective functions: \bold{O1}, \bold{O2}, and \bold{O3}.
}
\note{
The distance between two points is computed as the Euclidean distance between
them. This computation assumes that the optimization is operating in the
two-dimensional Euclidean space, i.e. the coordinates of the sample points
and candidate locations should not be provided as latitude/longitude.
The \pkg{spsann}-package has no mechanism to check if the coordinates are
projected: the user is responsible for making sure that this requirement
is attained.

The (only) difference of the \code{optimCLHS} function to the original
Fortran implementation of Minasny and McBratney (2006), and to the
\code{clhs} function implemented in the \pkg{\link[clhs]{clhs}} package by
Pierre Roudier, is in the annealing schedule.
}
\section{Marginal sampling strata}{

Reproducing the marginal distribution of the numeric covariates depends upon
the definition of marginal sampling strata. \emph{Equal-area} marginal
sampling strata are defined using the sample quantiles estimated with
\code{\link[stats]{quantile}} using a continuous function (\code{type = 7}),
that is, a function that interpolates between existing covariate values to
estimate the sample quantiles -- this is the procedure implemented in the
method of Minasny and McBratney (2006), which creates breakpoints that do
not occur in the population of existing covariate values. Depending on the
level of discretization of the covariate values, that is, how many
significant digits they have, this can create repeated breakpoints,
resulting in empty marginal sampling strata. The number of empty marginal
sampling strata will ultimately depend on the frequency distribution of the
covariate, and on the number of sampling points.
}

\section{Correlation between numeric covariates}{

The \emph{correlation} between two numeric covariates is measured using the
sample Pearson's \emph{r}, a descriptive statistic that ranges from $-1$ to
$+1$. This statistic is also known as the sample linear correlation
coefficient.
}

\section{Multi-objective optimization}{

A method of solving a multi-objective optimization problem (MOOP) is to
aggregate the objective functions into a single \emph{utility function U}.
In the \pkg{spsann} package, as in the original CLHS, the aggregation is
performed using the \emph{weighted sum method}, which uses weights to
incorporate the preferences of the user about the relative importance of
each objective function. When the user has no preference, the objective
functions receive equal weights.

The weighted sum method is affected by the relative magnitude of the
different objective function values. The objective functions implemented in
\code{optimCLHS} have different units and orders of magnitude. The
consequence is that the objective function with the largest values,
generally \bold{O1}, may have a numerical dominance during the optimization.
In other words, the weights will not express the true preferences of the
user, and the meaning of the utility function becomes unclear -- the
optimization will favour the objective function which is numerically
dominant.

An efficient solution to avoid numerical dominance is to transform the
objective functions so that they are constrained to the same approximate
range of values, at least in the end of the optimization. However, as in the
original CLHS, \code{optimCLHS} uses the naive aggregation method, which
ignores that the three objective functions have different units and orders
of magnitude. The same aggregation procedure is implemented in the
\pkg{clhs} package.
}
\examples{
require(sp)
data(meuse.grid)
candi <- meuse.grid[, 1:2]
covars <- meuse.grid[, 5]
weights <- list(O1 = 0.5, O3 = 0.5)
schedule <- scheduleSPSANN(chains = 1, initial.temperature = 20)
\dontrun{
set.seed(2001)
res <- optimCLHS(points = 100, candi = candi, covars = covars,
                 use.coords = TRUE, weights = weights, schedule = schedule)
objSPSANN(res) -
  objCLHS(points = res, candi = candi, covars = covars, use.coords = TRUE,
          weights = weights)
}
}
\author{
Alessandro Samuel-Rosa \email{alessandrosamuelrosa@gmail.com}
}
\references{
Edzer Pebesma, Jon Skoien with contributions from Olivier Baume, A. Chorti,
D.T. Hristopulos, S.J. Melles and G. Spiliopoulos (2013).
\emph{intamapInteractive: procedures for automated interpolation - methods
only to be used interactively, not included in \code{intamap} package.} R
package version 1.1-10.

van Groenigen, J.-W. \emph{Constrained optimization of spatial sampling:
a geostatistical approach.} Wageningen: Wageningen University, p. 148, 1999.

Walvoort, D. J. J.; Brus, D. J. & de Gruijter, J. J. An R package for
spatial coverage sampling and random sampling from compact geographical
strata by k-means. \emph{Computers & Geosciences}. v. 36, p. 1261-1267, 2010.

Minasny, B.; McBratney, A. B. A conditioned Latin hypercube method for
sampling in the presence of ancillary information. \emph{Computers &
Geosciences}, v. 32, p. 1378-1388, 2006.

Minasny, B.; McBratney, A. B. Conditioned Latin Hypercube Sampling for
calibrating soil sensor data to soil properties. Chapter 9. Viscarra Rossel,
R. A.; McBratney, A. B.; Minasny, B. (Eds.) \emph{Proximal Soil Sensing}.
Amsterdam: Springer, p. 111-119, 2010.

Roudier, P.; Beaudette, D.; Hewitt, A. A conditioned Latin hypercube sampling
algorithm incorporating operational constraints. \emph{5th Global Workshop on
Digital Soil Mapping}. Sydney, p. 227-231, 2012.
}
\seealso{
\code{\link[clhs]{clhs}}, \code{\link[spsann]{optimACDC}}
}
\concept{
simulated annealing

spatial trend
}
\keyword{iteration}
\keyword{optimize}
\keyword{spatial}

