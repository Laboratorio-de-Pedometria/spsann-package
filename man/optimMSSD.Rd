% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/optimMSSD.R
\name{optimMSSD}
\alias{objMSSD}
\alias{optimMSSD}
\title{Optimization of sample configurations for spatial interpolation}
\usage{
optimMSSD(points, candi, x.max, x.min, y.max, y.min, iterations = 10000,
  acceptance = list(initial = 0.99, cooling = iterations/10),
  stopping = list(max.count = iterations/10), plotit = TRUE, boundary,
  progress = TRUE, verbose = TRUE, greedy = FALSE)

objMSSD(candi, points)
}
\arguments{
  \item{points}{Integer value, integer vector, data frame
  or matrix. If \code{points} is an integer value, it
  defines the number of points that should be sampled from
  \code{candi}. If \code{points} is an integer vector, it
  contains the row indexes of \code{candi} that correspond
  to the points. If \code{points} is a data frame or
  matrix, it must have three columns: \code{[, 1]} the
  identification of each sample point (1, 2, ..., n),
  \code{[, 2]} the x-coordinates, and \code{[, 3]} the y-
  coordinates. The coordinates must be projected. If a data
  frame or matrix is used, \code{points} must be a subset of
  \code{candi}.} \item{candi}{Data frame or matrix with the
  candidate locations for the sample points. The coordinates
  must be projected.} \item{x.max,x.min,y.max,y.min}{Numeric
  value. The minimum and maximum quantity of random noise
  to be added to the x and y coordinates. The minimum
  quantity must be equal to, at least, the minimum distance
  between two neighbouring candidate locations. The units
  are the same as of the coordinates.} 
  \item{iterations}{Integer. The maximum number of iterations that should
  be used for the optimization.} \item{acceptance}{List
  with two named sub-arguments: \code{initial} -- numeric
  value between 0 and 1 defining the initial acceptance
  probability, and \code{cooling} -- a numeric value
  defining the exponential factor by witch the acceptance
  probability decreases at each iteration. Defaults
  to \code{acceptance = list(initial = 0.99, cooling =
  iterations / 10)}.} \item{stopping}{List with one named
  sub-argument: \code{max.count} -- integer value defining
  the maximum allowable number of iterations without
  improvement of the objective function value. Defaults to
  \code{stopping = list(max.count = iterations / 10)}. More
  options may be included in the future.} 
  \item{plotit}{Logical for plotting the optimization results. This
  includes a) the progress of the objective function values
  and acceptance probabilities, and b) the original points,
  the perturbed points and the progress of the maximum
  perturbation in the x- and y-coordinates. The plots are
  updated at each 10 iterations. Defaults to \code{plotit
  = TRUE}.} \item{boundary}{SpatialPolygon. The boundary
  of the spatial domain. Mandatory if \code{plotit =
  TRUE}.} \item{progress}{Logical for printing a progress
  bar. Defaults to \code{progress = TRUE}.} 
  \item{verbose}{Logical for printing messages about the progress of the
  optimization.} \item{greedy}{Logical value. Should the
  optimization be done using a greedy algorithm, that is,
  accepting only better system configurations? Defaults to
  \code{greedy = FALSE}.}
}
\value{
\code{objMSSD} returns a numeric value: the MSSD between a
set of points and all grid cells. \code{optimMSSD} returns
a matrix: the optimized sample configuration with the
evolution of the energy state during the optimization as an
attribute.
}
\description{
Optimize a sample configuration for spatial interpolation.
The criterion used is the mean squared shortest distance
(\code{optimMSSD}). \code{objMSSD} computes the MSSD between
a set of points and all grid cells.
}
\details{
Euclidean distances between points are calculated. This
computation requires the coordinates to be projected. The
user is responsible for making sure that this requirement is
attained.
}
\examples{
require(pedometrics)
require(sp)
require(rgeos)
require(SpatialTools)
data(meuse.grid)
candi <- meuse.grid[, 1:2]
coordinates(candi) <- ~ x + y
gridded(candi) <- TRUE
boundary <- as(candi, "SpatialPolygons")
boundary <- gUnionCascaded(boundary)
candi <- coordinates(candi)
candi <- matrix(cbind(c(1:dim(candi)[1]), candi), ncol = 3)
x.max <- diff(bbox(boundary)[1, ])
y.max <- diff(bbox(boundary)[2, ])
set.seed(2001)
res <- optimMSSD(points = 100, candi = candi, x.max = x.max, x.min = 40,
                 y.max = y.max, y.min = 40, iterations = 1000,
                 boundary = boundary)
tail(attr(res, "energy.state"), 1) # 9896.487
objMSSD(candi = candi, points = res)
}
\author{
Alessandro Samuel-Rosa
\email{alessandrosamuelrosa@gmail.com}
}
\references{
Brus, D. J.; de Gruijter, J. J.; van Groenigen, J. W.
Designing spatial coverage samples using the k-means
clustering algorithm. In: P. Lagacherie, A. M.; Voltz,
M. (Eds.) \emph{Digital soil mapping - an introductory
perspective}. Elsevier, v. 31, p. 183-192, 2006. de
Gruijter, J. J.; Brus, D.; Bierkens, M.; Knotters, M.
\emph{Sampling for natural resource monitoring}. Berlin:
Springer, p. 332, 2006. Walvoort, D. J. J.; Brus, D. J.; de
Gruijter, J. J. An R package for spatial coverage sampling
and random sampling from compact geographical strata
by k-means. \emph{Computers and Geosciences}. v. 36, p.
1261-1267, 2010.
}
\seealso{
\code{\link[raster]{distanceFromPoints}},
\code{\link[spcosa]{stratify}}.
}
\concept{
simulated annealing simulated annealing
}
\keyword{optimize}
\keyword{spatial}

