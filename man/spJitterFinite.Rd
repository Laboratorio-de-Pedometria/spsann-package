% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/spJitter.R
\name{spJitterFinite}
\alias{spJitterFinite}
\title{Random perturbation of spatial points}
\usage{
spJitterFinite(points, candi, x.max, x.min, y.max, y.min, which.point)
}
\arguments{
\item{points}{Integer value, integer vector, data frame or matrix. If
\code{points} is an integer value, it defines the number of points that
should be randomly sampled from \code{candi} to form the starting system
configuration. If \code{points} is a vector of integer values, it contains
the row indexes of \code{candi} that correspond to the points that form the
starting system configuration. If \code{points} is a data frame or matrix,
it must have three columns in the following order: \code{[, "id"]} the
row indexes of \code{candi} that correspond to each point, \code{[, "x"]}
the projected x-coordinates, and \code{[, "y"]} the projected y-coordinates.
Note that in the later case, \code{points} must be a subset of \code{candi}.}

\item{candi}{Data frame or matrix with the candidate locations for the
perturbed points. \code{candi} must have two columns in the following
order: \code{[, "x"]} the projected x-coordinates, and \code{[, "y"]} the
projected y-coordinates.}

\item{x.max,x.min,y.max,y.min}{Numeric value. The minimum and maximum
quantity of random noise to be added to the projected x- and y-coordinates.
The minimum quantity should be equal to, at least, the minimum distance
between two neighbouring candidate locations. The units are the same as of
the projected x- and y-coordinates. If missing, they will be estimated from
\code{candi}.}

\item{which.point}{Integer values defining which point should be perturbed.}
}
\value{
A matrix with the jittered projected coordinates of the points.
}
\description{
Perturb the coordinates of spatial points (\sQuote{jittering}).
}
\details{
There are two ways of jittering the coordinates. They differ on how the
set of candidate locations is defined. The first method is implemented in
\code{spJitterFinite} and uses a finite set of candidate locations for the
perturbed points. In other words, the set of candidate locations must be
discretized.

The second method uses an infinite set of candidate locations, that is, the
candidate locations do not have to be discretized. All that is needed is a
polygon indicating the boundary of the spatial domain. This method is not
implemented (yet) because it is more computationally demanding. When a point
is jittered, it is necessary to check if it lays inside the spatial domain.

Using a finite set of candidate location has one important inconvenience.
When a point is jittered, it may be that the new location already was
occupied by another point. If this happens, \code{spJitterFinite} tries to
find another new location for that point as many times as there are points
in \code{points}. The reason for this is that the more points there are in
\code{points}, the more likely it is that the new location already is
occupied by another point.
}
\examples{
require(sp)
data(meuse.grid)
meuse.grid <- as.matrix(meuse.grid[, 1:2])
meuse.grid <- matrix(cbind(1:dim(meuse.grid)[1], meuse.grid), ncol = 3)
pts1 <- sample(c(1:dim(meuse.grid)[1]), 155)
pts2 <- meuse.grid[pts1, ]
pts3 <- spJitterFinite(points = pts2, candi = meuse.grid, x.min = 40,
                      x.max = 100, y.min = 40, y.max = 100, which.point = 10)
plot(meuse.grid[, 2:3], asp = 1, pch = 15, col = "gray")
points(pts2[, 2:3], col = "red", cex = 0.5)
points(pts3[, 2:3], pch = 19, col = "blue", cex = 0.5)

# Cluster of points
pts1 <- c(1:55)
pts2 <- meuse.grid[pts1, ]
pts3 <- spJitterFinite(points = pts2, candi = meuse.grid, x.min = 40,
                      x.max = 80, y.min = 40, y.max = 80, which.point = 1)
plot(meuse.grid[, 2:3], asp = 1, pch = 15, col = "gray")
points(pts2[, 2:3], col = "red", cex = 0.5)
points(pts3[, 2:3], pch = 19, col = "blue", cex = 0.5)
}
\author{
Alessandro Samuel-Rosa \email{alessandrosamuelrosa@gmail.com}
}
\references{
Edzer Pebesma, Jon Skoien with contributions from Olivier Baume, A. Chorti,
D.T. Hristopulos, S.J. Melles and G. Spiliopoulos (2013).
\emph{intamapInteractive: procedures for automated interpolation - methods
only to be used interactively, not included in intamap package.} R package
version 1.1-10.

van Groenigen, J.-W. \emph{Constrained optimization of spatial sampling:
a geostatistical approach.} Wageningen: Wageningen University, p. 148, 1999.
}
\seealso{
\code{ssaOptim}, \code{\link[sp]{zerodist}},
\code{\link[base]{jitter}}, \code{\link[geoR]{jitter2d}}.
}
\concept{
jitter perturb
}

